{"meta":{"title":"Akiya の手記","subtitle":"Akiya の手記","description":null,"author":"Chiahao Lin (Akiya)","url":"https://purepennons.github.io"},"pages":[],"posts":[{"title":"人生就是這麼Koa...QAQ","slug":"人生就是這麼Koa-QAQ","date":"2017-07-11T06:54:00.000Z","updated":"2017-07-11T14:29:30.000Z","comments":true,"path":"2017/07/11/人生就是這麼Koa-QAQ/","link":"","permalink":"https://purepennons.github.io/2017/07/11/人生就是這麼Koa-QAQ/","excerpt":"","text":"人生就是這麼 Koa(2) … QAQ為什麼要 Koa? 而且還有可怕的 Error Handling … Sync 的 try… catch(err)… fn(err, callback) Promise.then().catch(err) 不同方式產生的 Error，沒有統一的 handle 方法。(對自己好一點，你值得擁有更好 &gt;.0) 快速 Review 一下 Generator Generator with Promise12345678910111213141516171819// generator readFilevar Promise = require('bluebird')var fs = Promise.promisifyAll(require('fs'))function* gen() &#123; try &#123; var data = yield fs.readFileAsync('file1') console.log('result', data.toString()) &#125; catch(err) &#123; console.error('居然抓的到！！', err) &#125; return&#125;// 執行var g = gen()// result.value 為 readFileAsync 回傳的 Promisevar result = g.next()result.value .then(data =&gt; g.next(data)) // 將 result 扔回 generator .catch(err =&gt; g.throw(err)) 拿掉執行的程式碼12345678910111213// generator readFilevar Promise = require('bluebird')var fs = Promise.promisifyAll(require('fs'))function* gen() &#123; try &#123; var data = yield fs.readFileAsync('file1') console.log('result', data.toString()) &#125; catch(err) &#123; console.error('居然抓的到！！', err) &#125; return&#125; 等等，不對啊，要是我有很多非同步操作勒？1234567891011121314151617181920212223// multi_asyncvar Promise = require('bluebird')var fs = Promise.promisifyAll(require('fs'))function* gen() &#123; try &#123; var data1 = yield fs.readFileAsync('file1') console.log('result1', data1.toString()) var data2 = yield fs.readFileAsync('file2') console.log('result2', data2.toString()) var data3 = yield fs.readFileAsync('file3') console.log('result2', data3.toString()) &#125; catch(err) &#123; console.error('居然抓的到！！', err) &#125; return&#125;// 執行var g = gen()g.next().value .then(data1 =&gt; g.next(data1).value) .then(data2 =&gt; g.next(data2).value) .then(data3 =&gt; g.next(data3).value) .catch(err =&gt; g.throw(err)) 本身執行過程是可以疊代的 (Iterative)，因此可以寫成執行器 (executor)12345678910111213// executorfunction run(gen)&#123; var g = gen() function next(data) &#123; var result = g.next(data) if (result.done) return result.value result.value .then(data =&gt; next(data)) .catch(err =&gt; g.throw(err)) &#125; next()&#125;run(gen) co module TJ 大神作品，Generator auto runner co(fn*) 執行 generator 並 return Promise，因此允許 Generator in Generator co.wrap(fn*) 可直接將 generator 轉換成 return Promise 的一般 function 12345678910111213141516// use co as auto runnerco(function* () &#123; var result = yield Promise.resolve(true) return result&#125;).then(value =&gt; console.log(value)).catch(err =&gt; console.log(err.stack))// use co to convert generator function to a regular functionvar fn = co.wrap(function* (val) &#123; return yield Promise.resolve(val)&#125;)fn(true) .then(value =&gt; console.log(value)) .catch(err =&gt; console.log(err.stack)) 所以講 Generator 是要幹嘛？ 因為 Koa1 就是基於 Generator (雖然我們主題是 Koa2) Koa1 與 Koa2 最大的差異就是 callback function 從 generator function → async/await function async/await 又是什麼？ 沒什麼，就是標準化的 Generator auto runner (ECMAScript 2016/ES7) 然後 function 宣告從 function*() → async function() 關鍵字 yield → await 一樣 return Promise 1234567async function fn() &#123; var result = await Promise.resolve(true) return result&#125;fn() .then(value =&gt; console.log(value)) .catch(err =&gt; console.log(err)) Koa - 講這麼多，終於來到了苦啊! 與 Express 概念類似的 node web framework，但是更陽春… Koa 相較於 express 的 callback 都是 regular function，其 callback function 皆是 async function，並自動幫你 handle 執行 當然如果你只想要在 Express 的 regular function 中，透過再宣告 async function 享受 async/await 語法，那就不用往下看了… Express123456const express = require('express')const app = express()app.get('/', function (req, res) &#123; res.send('Hello World')&#125;)app.listen(3000) Koa12345678const Koa = require('koa')const app = new Koa()app.use(async (ctx, next) =&gt; &#123; if (ctx.method === 'GET' &amp;&amp; ctx.path === '/') &#123; return ctx.body = 'Hello World' &#125;&#125;)app.listen(3000) 特色 真的非常陽春，連 router 都沒有 不過社群有各種功能的 middleware 的實作可套用 將所有的物件與操作皆封裝至 ctx 物件底下 包含 request 與 response 物件 設定了一堆 aliases 方便取用 middleware 包含 downstream 與 upstream 基本的 Error Handling 處理 404 以及不會洩漏 server stack error 一切都是 async function，開心的同步思維與 try… catch(err)… 吧！ … app 同一個 Koa 應用不只能掛載到一個 HTTP Server app.listen(port) 在特定 port 啟動監聽 與 http.createServer(app.callback()).listen(port) 等價 app.callback() 返回可被 node HTTP server 接受的 callback function (requestListener) requestListener: function(req, res) {} 12345const http = require('http');const Koa = require('koa');const app = new Koa();http.createServer(app.callback()).listen(3000);http.createServer(app.callback()).listen(3001); app.use(async (ctx, next) =&gt; {}) 套用 middleware await next() 之前為 downstream；await next() 之後為 upstream 下節再詳述… app.context 在 app 之間用於共享，類似 global value 的物件1234app.context.db = db();app.use(async (ctx) =&gt; &#123; console.log(ctx.db);&#125;); Middleware123456789101112// x-response-time：計算每次請求到返回間的運行時間// 這在 express 中非常難達成app.use(async function (ctx, next) &#123; // downstream start const start = new Date(); // downstream end await next(); // 往下層 middlware 的 downstream 執行 // upstream start const ms = new Date() - start; ctx.set('X-Response-Time', `$&#123;ms&#125;ms`); // upstream end&#125;); 再講一次，await next() 之前為 downstream；await next() 之後為 upstream 每層 middleware 遇到 await next() 之後，會暫停執行，往下層 middleware 的 downstream 直到最底層 middleware 的 downstream 執行完後，以倒序執行 upstream 的程式碼 下層 upstream 執行完後，繼續執行上一層的 upstream 直接拿官方現成的教學，還是 koa1 的範例… Simple Demo Code Warning: the demo cannot work 12345678910111213141516171819202122232425262728293031323334353637383940// token verifyapp.use(async (ctx, next) =&gt; &#123; // get by query string const &#123; token &#125; = ctx.query // get by cookies // const token_in_cookies = ctx.cookies.get('token', &#123;httpOnly: true&#125;) // get by headers // const &#123; authorization &#125; = ctx.headers // get by request body (need koa-bodyparser middleware) // const &#123; token &#125; = ctx.request.body try &#123; ctx.state.user = JWT.verify(token, 'secret_string') await next() &#125; catch(err) &#123; ctx.throw(401, 'Unauthorized') &#125;&#125;)// find friends of the usersapp.use(async ctx =&gt; &#123; const &#123; db &#125; = ctx const &#123; id &#125; = ctx.state.user try &#123; const friends = db.Friend.find(id) ctx.status = 200 // 預設 response status code = 200 ctx.set('ETag', 'a-unique-hash-id') ctx.body = &#123; code: 200, status: 'success' data: friends, &#125; &#125; catch(err) &#123; let err = new Error('db error') err.status = 500 err.expose = true // 不會洩漏 server stack 給 client throw err &#125;&#125;) Context, Request 與 Response 的用法還是去看官方文件最快，後面只提出幾個比較特別的。 Contextctx.state 用於傳遞暫存資料給不同 middlewares e.g. ctx.state.user = await User.find(id) Requestrequest.fresh (=ctx.fresh) 自動幫你透過 If-None-Match / ETag 與 If-Modified-Since / Last-Modified 比較快取是否過期 Content Negotiation Koa 的 request 物件可幫你設定一些請求的接受型態 request.accepts(types) request.acceptsEncodings(types) request.acceptsCharsets(charsets) request.acceptsLanguages(langs) Responseresponse.body (=ctx.body) 非常強大的 response 方式，無需根據返回類型選擇不同的回應方法，一律使用 response.body = xxx 接受 string, Buffer, Stream, Object || Array, null 類型 Object || Array 為 JSON.stringify 後的結果 Error Handling 在 Koa 的錯誤處理非常單純，直接 try… catch(err)…，然後拋出 error 即可 注意：拋出的 error，一樣會走完每層 upstream，所以可以在每層 middleware 中 catch 到底層丟上來的錯誤，因此非必要，不要修改 error，直接往上拋即可，否則取得的 error 可能不是預期的 Koa 預設的錯誤處理的行為是會將除了 404 與 err.expose=true 以外的錯誤全輸出至 stderr 可透過 app.on(&#39;error&#39;, cb(err, ctx)) 覆寫預設的錯誤處理 123456789101112131415161718192021222324app.use(async (ctx, next) =&gt; &#123; try &#123; // do nothing, just pass await next() &#125; catch(err) &#123; // get a error from the deeper middleware // don't modify, just throw up throw err // err = Error('Server Error') &#125;&#125;)app.use(async ctx =&gt; &#123; try &#123; throw new Error('Server Error') &#125; catch(err) &#123; throw err &#125;&#125;)app.on('error', (err, ctx) =&gt; &#123; // 覆寫預設錯誤處理的行為 // 若是發生的錯誤會導致 Koa 連 response 也無法，則會額外傳遞錯誤發生時的 ctx console.error('error', err.stack)&#125;) Router Koa 的第三方套件有許多套實作，這邊介紹最流行的 koa-router 特色 Express-style routing e.g. app.get, app.put, app.post … callback 可吃 regular function, generator function 與 async function 根據定義的 routing，自動提供 OPTIONS 方法 並提供自動回應 405 Method Not Allowed 與 501 Not Implemented 的功能 router 可巢狀定義再合併 基本用法123456789const app = require('koa')()const router = require('koa-router')()router.get('/', async (ctx, next) =&gt; &#123;...&#125;)router.post('/:variable', async (ctx, next) =&gt; &#123;...&#125;)app .use(router.routes()) .use(router.allowedMethods()) router.get|put|post|patch|delete(path, ...middleware)：routing 定義 router.routes()：返回全部定義的 routing 的 middleware router.allowedMethods()：返回允許的 OPTIONS 的 middleware，內容為所有定義的 routing 的方法 router.use([path], ...middleware)：可根據 routing 套用多個 middleware router.param(param, middleware)：若定義的 routing 有符合 param 可在進入 routing 前，透過 middleware 預先處理這個 param 12345678router .param('user', (id, ctx, next) =&gt; &#123; ctx.user = users[id] if (!ctx.user) return ctx.status = 404 return next() &#125;) .get('/users/:user', async ctx =&gt; ctx.body = ctx.user) .get('/users/:user/friends', async ctx =&gt; ctx.body = await ctx.user.getFriends()) 複雜的巢狀例子 假設現在有 /auth 與 /users 兩支 routing，分別定義在 auth.js 與 users.js，並透過 routes/index.js 合併 routes。在 Koa 中直接引用 routes/index.js 匯出的 route。 123456789101112131415161718192021222324252627282930313233343536373839404142// auth.jsconst Router = require('koa-router')const router = Router()router .use(someMiddleware) .post('/login', ctx =&gt; &#123;...&#125;) .post('/logout', ctx =&gt; &#123;...&#125;)module.exports = router// users.jsconst Router = require('koa-router')const router = Router()const auth_mid = require('../middlewares/auth')router .get('/:userID', ctx =&gt; &#123; const &#123; userID &#125; = ctx.params // 透過 ctx.params 存取 route url 變數 // ctx.body = ... &#125;)module.exports = router// routes/index.js (routes)const Router = require('koa-router')const router = Router()const auth_routes = require('./auth')const users_routes = require('./users')router .use('/auth', auth_routes.routes(), auth_routes.allowedMethods()) .use('/users', users_routes.routes(), users_routes.allowedMethods())module.exports = router// index.js (koa app)const Koa = require('koa')const router = require('./routes/index')const app = new Koa()app.use(router.routes())app.listen(3000)// 實際上使用時的 router// POST -&gt; /auth/login// POST -&gt; /auth/logout// GET -&gt; /users/&#123;userID&#125; 常用的 middleware koa-bodyparser：parsing body request koa-logger：會有 request/response 的資訊輸出 kcors：設定 cross domain access koa-json：讓 json response 的 router 帶有 pretty query string，可美化 json response koa-static：指定資料夾輸出靜態檔案 koa-session：session in Koa 使用 compose 合併 middleware koa-compose 可以將多個 middleware 合併成一個，讓程式碼更加優雅 123456const compose = require('koa-compose')app.use(compose([ middleware1, middleware2, ...])) Simple JWT Demo with Koa2Reference koajs: http://koajs.com/ Koa guide: https://github.com/koajs/koa/blob/master/docs/guide.md js543: http://slides.com/chiahaolin/js543","categories":[{"name":"Backend","slug":"Backend","permalink":"https://purepennons.github.io/categories/Backend/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://purepennons.github.io/tags/node-js/"},{"name":"koa","slug":"koa","permalink":"https://purepennons.github.io/tags/koa/"},{"name":"backend","slug":"backend","permalink":"https://purepennons.github.io/tags/backend/"},{"name":"web","slug":"web","permalink":"https://purepennons.github.io/tags/web/"}]},{"title":"JSON-WEB-TOKEN-JWT","slug":"毫無反應，就是個 JWT","date":"2017-06-25T00:40:00.000Z","updated":"2017-07-11T07:02:52.000Z","comments":true,"path":"2017/06/25/毫無反應，就是個 JWT/","link":"","permalink":"https://purepennons.github.io/2017/06/25/毫無反應，就是個 JWT/","excerpt":"","text":"毫無反應，就是個 JWT (JSON Web Token)什麼是 JWT？ 一種基於 JSON 格式，用於傳輸信任資訊的簽章 (signature) 與編碼 (encoding) 技術 因此資料可以反解 (decoding) 回去 常用於分散式環境下，取代 session 認證，可擴展的解決方案 單點認證 JWT 描述使用者資訊，可達成無狀態 (stateless) e.g. eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ Session 的問題？ Server 記憶體消耗 擴展困難 跨主機間的 session 共享？ CSRF JWT 運作流程 https://cdn.auth0.com/content/jwt/jwt-diagram.png Server-side 無需保存 users 資料 =&gt; 無記憶體消耗 JWT 本身包含所需的使用資料，可達成 stateless HTTP APIs =&gt; 方便擴展 JWT 的存放可以完全不透過 Cookies =&gt; 沒有 CSRF 的可能 JWT 原理 Header 描述使用的簽章演算法，並透過 Base64URL 編碼 對稱 / 非對稱加密皆可使用，通常使用 HMAC256 Payload 描述使用者與提供者所需要的資訊，並透過 Base64URL 編碼 避免儲存敏感資料 另外有標準特別規範的聲明 (並未硬性要求) iss: Issuer，JWT 的簽章者，可驗證是否原本的簽章者簽章 sub: Subject，此 JWT 底下服務的服務，需要局部或全域唯一 (unique) aud: Audience，接收此 JWT 的使用者，一個可被 identify 的 StringOrURI exp: JWT 過期時間，此數值必須大於簽章時間，單位為秒 nbf: 定義在此時間點以前，JWT 都是不可用的 iat: JWT 的簽章時間 jti: JWT 的唯一識別，可用於一次性 koken，避免重放攻擊 (replay attack) Signature 將 Header 與 Payload 以 . 相連，然後根據指定的演算法，加上 secret key 簽章 若是使用非對稱 RSA 加密，則透過 private key 簽章，然後透過 public key 驗證 將 Header、Payload 與 Signature 分別以 . 相連的結果，即為我們產生的 token 注意 通常會使用 Base64URL 編碼取代 Base64 Base64URL 會另外處理瀏覽器 URL 上的特殊符號 e.g. “+” =&gt; “-”, “/” =&gt; “_” Base64URL 是可反解的，避免儲存敏感資料 Secret Key 只存在 Server，需妥善保管 JWT 的產生與驗證皆只在 Server-side 完成 驗證 將 Client 傳輸過來的 token，取出 Header 與 Payload 的部份，根據 Header 描述的演算法，配合 secret key 重新運算簽章流程，比較是否與 Signature 相同，相同則表示未經偽造。 另外將 Payload 解碼，取出聲明依序驗證（可包含規範與自定的聲明） e.g. 驗證 exp 是否有大於當前時間，若否，則失效 使用 Client 每次請求時，皆會帶上 token 給 Server 驗證 正規作法是透過 HTTP 的 Authorization header，以 Bearer ${token} 的形式帶上 e.g. Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ Bearer 只是描述要以 JWT 的方式驗證，沒有硬性規定，以 Client 與 Server 約定為主 亦可透過 GET 的的 query string (較不建議) 或 set cookies (有 CSRF 風險) 的形式達成 JWT demo with koa2 Github: https://github.com/purepennons/jwt_demo JWT 的繆誤 並非加密 (encryption) 機制，資料可被解碼，並且只是單純的驗證資訊是否被竄改 因此沒有能力確保資料安全，避免存放敏感資料 確保資料安全請用 SSL/TLS 其他 根據使用的安全性需求，調整 token 的壽命，或者是使用一次性 token jwt.io 有提供 Debugger 與建議的各語言實作套件清單 node: node-jsonwebtoken 參考資料 Web 技術中的 Session 是什麼？ What is SSL, TLS and HTTPS? 讓我們來談談 CSRF 5 Easy Steps to Understanding JSON Web Tokens (JWT) jwt.io JSON Web Token (JWT) draft-ietf-oauth-json-web-token-32","categories":[{"name":"Security","slug":"Security","permalink":"https://purepennons.github.io/categories/Security/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://purepennons.github.io/tags/node-js/"},{"name":"JWT","slug":"JWT","permalink":"https://purepennons.github.io/tags/JWT/"},{"name":"security","slug":"security","permalink":"https://purepennons.github.io/tags/security/"}]},{"title":"AVA: Futuristic JavaScript Test Runner","slug":"ava-futuristic-javaScript-test-runner","date":"2017-05-27T06:13:00.000Z","updated":"2017-07-11T07:01:50.000Z","comments":true,"path":"2017/05/27/ava-futuristic-javaScript-test-runner/","link":"","permalink":"https://purepennons.github.io/2017/05/27/ava-futuristic-javaScript-test-runner/","excerpt":"","text":"AVA Futuristic JavaScript test runner https://github.com/avajs/ava Why AVA? Simple test syntax like tape (e.g. t.deepEqual, t.pass, …) No implicit globals like mocha (e.g describe , it) Runs tests concurrently (troll!) Process isolation for each test file Support ES2017 by Babel (stage-4) Support: Promise Generator async/await Observable … Basic usage Take a look 1234import test from 'ava';test('just a demo', t =&gt; &#123; t.deepEqual([1, 2], [1, 2]);&#125;); Run 1234567891011121314# install ava cli$ npm install -g ava# install dependency &amp; run$ npm install ava# run$ ava# auto reload$ ava --watch# Or you can add the testing script for package.json.$ ava --init$ npm test Simple result Verbose result Tap style result Can integrate with any tap reporters. Integrate with tap-nyan Enhanced assertion messages Fail case 123456789101112import test from 'ava';test('enhanced assertion messages - case 1', t =&gt; &#123; const a = &#123;a: 10, b: 20&#125;; const b = &#123;a: 20, b: 20&#125; t.deepEqual(a, b);&#125;);test('enhanced assertion messages - case 2', t =&gt; &#123; const a = 'bar'; const b = 'bar'; const c = 'baz'; t.true((a === b) &amp;&amp; (b === c));&#125;); Result case 1 case 2 You can use any assertion library (e.g. chai, node assert). But the magic assert only supports with default assertion library. Babel Write babel presets in ava field of package.json. 12345\"ava\": &#123; \"babel\": &#123; \"presets\": [\"es2015\", \"stage-0\"] &#125;&#125; Or just inherit from .babelrc. 123\"ava\": &#123; \"babel\": \"inherit\"&#125; If you need to load the extra babel modules, use require option in the babel field. 1234567\"ava\": &#123; \"babel\": \"inherit\", \"require\": [ \"babel-register\", \"babel-polyfill\" ]&#125; Or you want to load from an entrypoint. 123456\"ava\": &#123; \"babel\": \"inherit\", \"require\": [ \"./test/set-babel.js\" ]&#125; ./test/set-babel.js 12require('babel-register')require('babel-polyfill') Test coverage Cannot use istanbul for code coverage. Use nyc (Istanbul CLI) instead. 1$ nyc ava Promise12345test(t =&gt; &#123; return somePromise().then(result =&gt; &#123; t.is(result, 'unicorn'); &#125;);&#125;); Generator1234test(function* (t) &#123; const value = yield generatorFn(); t.true(value);&#125;); async/await12345678910test(async function (t) &#123; const value = await promiseFn(); t.true(value);&#125;);// Async arrow functiontest(async t =&gt; &#123; const value = await promiseFn(); t.true(value);&#125;); Observable123456789test(t =&gt; &#123; t.plan(3); return Observable.of(1, 2, 3, 4, 5, 6) .filter(n =&gt; &#123; // Only even numbers return n % 2 === 0; &#125;) .map(() =&gt; t.pass());&#125;); Callback use test.cb() t.end() only work with test.cb() , must be called at the end of callback. 1234test.cb(t =&gt; &#123; // `t.end` automatically checks for error as first argument fs.readFile('data.txt', t.end);&#125;); Assertions .pass([message]) / .fail([message]) .truthy(value, [message]) / .falsy(value, [message]) .true(value, [message]) / .false(value, [message]) .is(value, expected, [message]) / .not(value, expected, [message]) .deepEqual(value, expected, [message]) / .notDeepEqual(value, expected, [message]) .throws(function|promise, [error, [message]]) / .notThrows(function|promise, [message]) .regex(contents, regex, [message]) / .notRegex(contents, regex, [message]) .ifError(error, [message]) .snapshot(contents, [message]) Snapshot AVA can take a snapshot which uses jest-snapshot under the hood. Example: hello.jsx 1234import React from 'react'import ReactDOM from 'react-dom'const Hello = () =&gt; &lt;h1&gt;Hello&lt;/h1&gt;export default Hello react.spec.js 123456789import test from 'ava'import React from 'react'import render from 'react-test-renderer'import Hello from '../app/hello.jsx'test('test react component', async t =&gt; &#123; const dom_tree = render.create(&lt;Hello /&gt;).toJSON() console.log(dom_tree) t.snapshot(dom_tree)&#125;) It will create a __snapshots__ folder in the test folder and contains the following result. First run Snapshot result And when the result is not equal to the snapshot, it will fail the test. If you want to update the snapshot, just use --update-snapshots or -u options.https://d2mxuefqeaa7sj.cloudfront.net/s_40E81CC28D06286B542B06554F0AD203FFC3CC719886DFCA8E86E84FE46DB9D5_1495473968079_image.png before/after Hooks test.before(): Hooks before the first test. 12345const db = init_db(db_config)test.before(async t =&gt; &#123; // db connection await db.sequelize.sync(&#123; force: true &#125;)&#125;) test.after(): Hooks after the last test. 12345678910111213141516171819202122232425 test.after.always(async t =&gt; &#123; // close the db connection await db.sequelize.close() &#125;)``` - If you want to guarantee to run the hook (even failure), use `test.after.always()` ## beforeEach/afterEach Hooks- `test.beforeEach()`: Hooks before each test.```javascript test.beforeEach(async t =&gt; &#123; t.context.clients = &#123;&#125; &#125;)``` - `test.afterEach()`: Hooks after each test. - Same as `test.after()`, use `test.after.always()` to guarantee the hook. ```javascript test.afterEach.always(async t =&gt; &#123; Object.keys(t.context.clients) .map(client =&gt; t.context.clients[client].disconnect()) &#125;) You can share the context (t.context) in each test. (Only works for beforeEach/afterEach hooks) 123test(async t =&gt; &#123; t.context.clients['client1'] = socket.connect(socket_url, client_ops)&#125;) Other APIs test.serial(): Force test serialization. test.only(): Running specific tests (effect all test files). test.skip(): Just skip the test. test.todo(): Add a todo test, AVA will ignore it. test.failing(): Mark known failure. Mocking AVA doesn’t support mocking, just use any other mocking library like Sinon.js or testdouble.js. Debug in Chrome DevTools Launch test file by inspect-process. Just use debugger keyword in the test file. 12$ npm install --global inspect-process$ inspect node_modules/ava/profile.js &lt;your-test-file&gt; Debug in VS Code Add following configuration in the launch.json Set the breakpoints and run. 1234567891011\"configurations\": [ &#123; \"type\": \"node\", \"request\": \"launch\", \"name\": \"ava test\", \"program\": \"$&#123;workspaceRoot&#125;/node_modules/ava/profile.js\", \"args\": [ \"$&#123;file&#125;\" ] &#125;] Trolls &amp; Bad things Must run with ava-cli Only can limit the execution time by CLI (global setting) ava –timeout=30s Cannot set for each test case. Must write tests carefully because of the concurrency. e.g. Test transactions in a same table. Force test serialization test.serial() $ ava --serial Other reference TypeScript in ava: https://github.com/avajs/ava/blob/master/docs/recipes/typescript.md Flow in AVA: https://github.com/avajs/ava/issues/986 React AVA workshop: https://github.com/kentcdodds/react-ava-workshop Testing React components: https://github.com/avajs/ava/blob/master/docs/recipes/react.md Configuring Babel: https://github.com/avajs/ava/blob/master/docs/recipes/babelrc.md Setting up AVA for browser testing: https://github.com/avajs/ava/blob/master/docs/recipes/browser-testing.md","categories":[{"name":"Testing","slug":"Testing","permalink":"https://purepennons.github.io/categories/Testing/"}],"tags":[{"name":"ava","slug":"ava","permalink":"https://purepennons.github.io/tags/ava/"},{"name":"test","slug":"test","permalink":"https://purepennons.github.io/tags/test/"},{"name":"node.js","slug":"node-js","permalink":"https://purepennons.github.io/tags/node-js/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-05-08T17:00:41.000Z","updated":"2017-05-08T17:00:41.000Z","comments":true,"path":"2017/05/09/hello-world/","link":"","permalink":"https://purepennons.github.io/2017/05/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}